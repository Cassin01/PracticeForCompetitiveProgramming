\documentclass[12pt]{jarticle}
\setlength{\textwidth}{170mm}
\setlength{\textheight}{260mm}
\setlength{\oddsidemargin}{-5mm}
\setlength{\topmargin}{-25mm}
\usepackage[dvipdfmx]{graphicx}
\usepackage{ascmac}

%後は検討事項とグラフの作成のみ！！
%検討事項にはプログラムを少し書き換えるのもあるので注意!!

\begin{document}
\begin{center}
  学籍番号: 4617041 氏名: 白江涼雅
\end{center}

{\LARGE 課題3 ハミング符号の繰り返しシミュレーション}

\section{目的}
課題1,2で行った内容を踏まえてシミュレーションプログラムを作成し、仮想的な通信環境を構築する技術を身につける.

\section{実験装置}
\begin{itemize}
 \item windows Xシリーズ
 \item Visualstdio2013
\end{itemize}

\section{実験結果}
実行結果は以下の通りになった.またグラフは最後のページにまとめた.
\begin{center}
  \textbf{表3: 試行回数$100000$ の時のブロック誤り率と理論値}
    \begin{tabular}{|c|c|} \hline
      $\varepsilon$ & ブロック誤り率の出力結果\\ \hline
      0.002500 & 0.000045 \\ \hline
      0.012500 & 0.001442 \\ \hline
      0.022500 & 0.004248 \\ \hline
      0.032500 & 0.008690 \\ \hline
      0.042500 & 0.014722 \\ \hline
      0.052500 & 0.021600 \\ \hline
      0.062500 & 0.028650 \\ \hline
      0.072500 & 0.038812 \\ \hline
      0.082500 & 0.047460 \\ \hline
      0.092500 & 0.058490 \\ \hline
      0.102500 & 0.069642 \\ \hline
    \end{tabular}
\end{center}

      
\section{検討事項}
\begin{enumerate}
\item 今回計測した$\varepsilon$の区間でBERが0になる確率が一番高い$\varepsilon = 0.0025$について考える.\\
  検討事項2にある通り,$P_e = {}_7C_2(0.0025)^2$より, $P_e \to 0$とみなし、試行回数を $n \to \infty$ とすると、ポアソン分布に従うとわかる.$P_e * n = \lambda$とし,式に表すと
  \begin{equation}
  P(X=k)=\frac{e^{-\lambda}{\lambda^k}}{k!}
  \end{equation}
  となる.$k\geq1$となればBERが0にならず計算できるため排反を考え,$P(X=0) \simeq 0$となる値をみつける.すなわち$P(X=0) = e^{-\lambda} \simeq 0$を考えれば良い.
  
  \begin{center}
    \textbf{表2:試行回数$n$ に対するハミング符号の誤り率$P(X=0)$の値}
    \begin{tabular}{|c|c|c|} \hline
      試行回数 $n$ & $\lambda$ & $P(X=0)=e-^{\lambda}$        \\ \hline
      100         &  $1.31 * 10^{-2}$ &  0.99                \\ \hline
      1000        &  $1.31 * 10^{-1}$ &  0.88                 \\ \hline
      10000       &  $1.31$          &  0.27                 \\ \hline
      100000      &  $13.1$          &  $2.04 * 10 ^{-6}$       \\ \hline
       \end{tabular}
  \end{center}

  直感的ではあるが,$n=10000$まではBERが0になる可能性があが,$n=100000$ではほぼ0となる.これより10万回以上の試行を行うことが推薦される.

\item
  ハミング符号を用いない場合は$P_e$と$\varepsilon$は同等の確率で誤る.一方,実験課題2であったように,ハミング符号を用いると7bitの中にも誤りがない場合と1つ誤りがある場合は正しく受け取ることができる.よってBERは
  \begin{equation}
P_e = {}_7C_2 * \varepsilon^2
  \end{equation}
  となる.よってハミング符号を用いた時の方が$P_e$は低くなる.
\item
  以下の表にまとめる.
\begin{center}
    \textbf{表3: 試行回数$100000$ の時のブロック誤り率と理論値}
    \begin{tabular}{|c|c|c|} \hline
      $\varepsilon$ & ブロック誤り率の出力結果　& 理論値 \\ \hline
      0.002500    &  0.000100 & 0.00013 \\ \hline
      0.012500    &  0.003300 & 0.00327 \\ \hline
      0.022500    &  0.009850 & 0.01063  \\ \hline
      0.032500    &  0.020100 & 0.0221   \\ \hline
      0.042500    &  0.033820 & 0.038    \\ \hline
      0.052500    &  0.049110 & 0.058   \\ \hline
      0.062500    &  0.065020 & 0.089   \\ \hline
      0.072500    &  0.087920 & 0.110   \\ \hline
      0.082500    &  0.106780 & 0.143   \\ \hline
      0.092500    &  0.131650 & 0.180   \\ \hline
      0.102500    &  0.155610 & 0.22    \\ \hline
    \end{tabular}
\end{center}
  比較すると,全体的に理論値のほうがやや大きい.理論値の計算の間違えか,プログラムの間違いかわからないままだ.
\end{enumerate}

\section{まとめ}
今回の実験では,ハミング符号の役割や通信技術についての理解が深まった.また,
シミュレーションプログラムの作成及び,結果について検討することでシミュレーションプログラムの利点や扱い方,注意しなければならないことを理解することができた.

\section{ソースコード}
\begin{center}  
\begin{verbatim}
#include <stdio.h>
#include <stdlib.h>
#include <random>
#define gyo 7 //ハミング符号
#define retu 4 //ハミング符号
#define k 3 //シンドロームの長さ
#define SIM 100000 //試行回数
#define probability 11 //桁上がり

int main(){
	int G[gyo][retu];//生成行列
	int H[gyo][k]; //検査行列
	int w[retu];  //情報系列
	int x[gyo];  //送信系列
	int y[gyo];  //受信系列
	int e[gyo];  //誤り符号
	int s[gyo]; //シンドローム生成
	double ran;
	int i, j,l,m;
	int tmp;
	int miss;
	double delta_plus = 0.01; //はじめの桁
	double delta;
	double syoki = 0.0025;
	int miss_count;
	double answer;

	//乱数発生準備
	std::mt19937 mt(41);
	std::uniform_real_distribution<double> r_rand(0.0, 1.0);


	//生成行列で必要な任意にきめるところの生成
	G[0][0] = 1; G[0][1] = 0; G[0][2] = 0; G[0][3] = 0;
	G[1][0] = 0; G[1][1] = 1; G[1][2] = 0; G[1][3] = 0;
	G[2][0] = 0; G[2][1] = 0; G[2][2] = 1; G[2][3] = 0;
	G[3][0] = 0; G[3][1] = 0; G[3][2] = 0; G[3][3] = 1;
	G[4][0] = 1; G[4][1] = 1; G[4][2] = 1; G[4][3] = 0;
	G[5][0] = 1; G[5][1] = 1; G[5][2] = 0; G[5][3] = 1;
	G[6][0] = 1; G[6][1] = 0; G[6][2] = 1; G[6][3] = 1;

	H[0][0] = 1; H[0][1] = 1; H[0][2] = 1;
	H[1][0] = 1; H[1][1] = 1; H[1][2] = 0;
	H[2][0] = 1; H[2][1] = 0; H[2][2] = 1;
	H[3][0] = 0; H[3][1] = 1; H[3][2] = 1;
	H[4][0] = 1; H[4][1] = 0; H[4][2] = 0;
	H[5][0] = 0; H[5][1] = 1; H[5][2] = 0;
	H[6][0] = 0; H[6][1] = 0; H[6][2] = 1;


	for (m = 0; m < probability; m++){
		delta = syoki + delta_plus * m;
		miss_count = 0;
		for (l = 0; l < SIM; l++){
			//wの生成
			for (i = 0; i < retu; i++){
				ran = r_rand(mt);
				if (ran < 0.5){
					w[i] = 0;
				}
				else{
					w[i] = 1;
				}
			}
		
			//xの生成
			for (i = 0; i < gyo; i++){
				tmp = 0;
				for (j = 0; j < retu; j++){
					tmp += w[j] * G[i][j];
				}
				if (tmp % 2 == 0){
					x[i] = 0;
				}
				else{
					x[i] = 1;
				}
			}
		
			//誤りeの生成
			for (i = 0; i < gyo; i++){
				ran = r_rand(mt);
				if (ran < delta){
					e[i] = 1;
				}
				else{
					e[i] = 0;
				}
			}

			//送信行列に誤りeを干渉させ,送信行列をつくる
			for (i = 0; i < gyo; i++){
				y[i] = (x[i] + e[i]) % 2;
			}
		
			//sの生成
			for (i = 0; i < k; i++){
				s[i] = 0;
				for (j = 0; j < gyo; j++){
					s[i] += y[j] * H[j][i];
				}
				if (s[i] % 2 == 1){
					s[i] = 1;
				}
				else{
					s[i] = 0;
				}
			}
		
			//どこ反転させるかの判定
			if (s[0] == 1 && s[1] == 1 && s[2] == 1){
				miss = 1;
			}
			else if (s[0] == 1 && s[1] == 1 && s[2] == 0){
				miss = 2;
			}
			else if (s[0] == 1 && s[1] == 0 && s[2] == 1){
				miss = 3;
			}
			else if (s[0] == 0 && s[1] == 1 && s[2] == 1){
				miss = 4;
			}
			else if (s[0] == 1 && s[1] == 0 && s[2] == 0){
				miss = 5;
			}
			else if (s[0] == 0 && s[1] == 1 && s[2] == 0){
				miss = 6;
			}
			else if (s[0] == 0 && s[1] == 0 && s[2] == 1){
				miss = 7;
			}
			else{
				miss = 0;
			}

			/*printf("%dビット目を反転させます\n", miss);*/

			if (y[miss - 1] == 0){
				y[miss - 1] = 1;
			}
			else{
				y[miss - 1] = 0;
			}
		
			for (i = 0; i < retu; i++){
				if (y[i] != x[i]){
					miss_count++;
				}
			}
		}
		answer = (double)miss_count / (SIM * retu);
		printf("εが%fのとき:%f\n", delta,answer);
	}
}
\end{verbatim}
\textbf{図2:ハミング符号を用いたシミュレーションのソースコード}
\end{center}

\section{参考文献}
\begin{thebibliography}{2}
\bibitem{} 統計WEB https://bellcurve.jp/statistics/course/6984.html (2018/1012 アクセス)
  \end{thebibliography}

\end{document}
